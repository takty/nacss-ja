{"version":3,"sources":["ja-segmenter.js"],"names":["window","NS","sortProperNouns","opts","pns","map","e","sort","a","b","length","IW","split","AW","AI1","PRE_KANJI","PRE_NUM","getSegment","str","properNouns","ts","c","push","getCharType","createCharTypeArray","ws","Array","fill","i","t0","t1","PAIRS","weightByCharTypes","strA","weightByPhrases","weightByPhraseAndType","CLS_ALL","CLS_WO_KANJI","CLS_ORIG","CHAR_PATTERNS","t","p","test","II","KK","HH","NN","OO","TT","HI","NH","NK","NI","ON","NO","phrases","factor","offset","ph","phA","phL","bgn","idx0","indexOfArray","idx1","prevCts","nextCts","prevW","nextW","tsL","includes","array","searchElement","fromIndex","match","j","createFragment","df","document","createDocumentFragment","temp","idx","appendPhrase","isOriginalCharPhrase","styleSegment","isOrig","style","appendChild","createTextNode","createElement","tar","cls","enabled","val","key","substr","startsWith","dataset","join","classList","add","remove","setClass","end","applySegmenter","initialize","applySegmenterToString","Object","assign","styleDisabled"],"mappings":"AAOA,aAEAA,OAAc,MAAUA,OAAc,OAAW,CAAC,EAClDA,OAAc,MAAM,GAAIA,OAAc,MAAM,IAAK,CAAC,EAGlD,CAAEC,IAoGD,SAASC,EAAgBC,GACxB,MAAMC,EAAMD,EAAkB,YAAEE,KAAIC,GAAK,IAAIA,KAC7CF,EAAIG,MAAK,CAACC,EAAGC,IACLA,EAAEC,OAASF,EAAEE,SAErBP,EAAkB,YAAIC,CACvB,CA6BA,MAAMO,EAAK,0lCAA0lCC,MAAM,KACrmCC,EAAK,0MAA0MD,MAAM,KAErNE,EAAY,4BAA4BF,MAAM,KAC9CG,EAAY,MAAMH,MAAM,KACxBI,EAAY,MAAMJ,MAAM,KAE9B,SAASK,EAAWC,EAAKC,GACxB,MAAMC,EAoCP,SAA6BF,GAC5B,MAAME,EAAK,GACX,IAAK,MAAMC,KAAKH,EACfE,EAAGE,KAAKC,EAAYF,IAErB,OAAOD,CACR,CA1CYI,CAAoBN,GACzBO,EAAKC,MAAMN,EAAGV,QAAQiB,KAAK,IAiElC,SAA2BP,EAAIK,GAC9B,IAAK,IAAIG,EAAI,EAAGA,EAAIR,EAAGV,OAAQkB,GAAK,EAAG,CACtC,MAAMC,EAAKT,EAAGQ,EAAI,GACZE,EAAKV,EAAGQ,GACdH,EAAGG,KAAOG,EAAMF,EAAKC,IAAO,IAAMC,EAAM,IAAMD,IAAO,IAAMC,EAAMF,EAAK,MAAQ,EAC/E,CACD,CArECG,CAAkBZ,EAAIK,GAEtB,MAAMQ,EAAO,IAAIf,GASjB,OARIC,EAAYT,QAAQwB,EAAgBD,EAAMR,EAAIN,GAAc,GAChEe,EAAgBD,EAAMR,EAAId,GAAK,GAC/BuB,EAAgBD,EAAMR,EAAIZ,EAAI,GAE9BqB,EAAgBD,EAAMR,EAAIX,GAAM,EAAG,GACnCqB,EAAsBF,EAAMb,EAAIK,EAAIV,EAAWqB,EAAc,KAAM,EAAG,GACtED,EAAsBF,EAAMb,EAAIK,EAAIT,EAAWqB,EAAc,IAAM,EAAG,GAE/D,CAACjB,EAAIK,EACb,CAMA,MAAMY,EAAe,WACfD,EAAe,YACfE,EAAe,MAEfC,EAAgB,CACrB,CAAC,IAAK,qBACN,CAAC,IAAK,qBACN,CAAC,IAAK,gBACN,CAAC,IAAK,WACN,CAAC,IAAK,gBACN,CAAC,IAAK,iDACN,CAAC,IAAK,aACN,CAAC,IAAK,QAWP,SAAShB,EAAYF,GACpB,IAAK,MAAOmB,EAAGC,KAAMF,EACpB,GAAIE,EAAEC,KAAKrB,GAAI,OAAOmB,EAEvB,MAAO,GACR,CAMA,MAAMT,EAAQ,CACb,MAAO,EAAG,KAAM,EAChB,KAAM,EACN,KAAM,GAAI,MAAO,GACjB,MAAO,EAAG,MAAO,EACjBY,GAAM,EAAGC,GAAM,EAAGC,GAAM,EAAIC,GAAM,EAAGC,GAAM,EAAGC,GAAM,EACpDC,GAAM,EACNC,GAAM,EAAGC,GAAM,EAAGC,GAAM,EACxBC,GAAM,EAAGC,GAAM,GAkEhB,SAASpB,EAAgBD,EAAMR,EAAI8B,EAASC,EAAQC,EAAS,GAC5D,IAAK,MAAMC,KAAMH,EAAS,CACzB,MAAMI,EAAM,IAAID,GACVE,EAAMD,EAAIjD,OAEhB,IAAK,IAAImD,EAAM,IAAK,CACnB,MAAMC,EAAOC,EAAa9B,EAAM0B,EAAKE,GACrC,IAAc,IAAVC,EAAa,MACjB,MAAME,EAAOF,EAAOF,EAEpBnC,EAAGqC,EAAOL,KAAYG,EAAMH,GAAUD,EACtC,IAAK,IAAI5B,EAAI,EAAGA,EAAIgC,EAAMH,EAAQ7B,GAAK,EACtCH,EAAGqC,EAAOL,EAAS7B,IAAOgC,EAAMH,EAEjCI,EAAMG,CACP,CACD,CACD,CAEA,SAAS7B,EAAsBF,EAAMb,EAAIK,EAAI8B,EAASU,EAASC,EAASC,EAAOC,GAC9E,MAAMC,EAAMjD,EAAGV,OAEf,IAAK,MAAMgD,KAAMH,EAAS,CACzB,MAAMI,EAAM,IAAID,GACVE,EAAMD,EAAIjD,OAEhB,IAAK,IAAImD,EAAM,IAAM,CACpB,MAAMC,EAAOC,EAAa9B,EAAM0B,EAAKE,GACrC,IAAc,IAAVC,EAAa,MACjB,MAAME,EAAOF,EAAOF,EAEpB,IACW,IAATE,GAA0B,IAATA,GAAcG,EAAQK,SAASlD,EAAG0C,EAAO,OAC1DE,IAASK,GAAQL,EAAOK,GAAOH,EAAQI,SAASlD,EAAG4C,KACnD,CACDvC,EAAGqC,IAASK,EACRH,EAAOvC,EAAGf,SAAQe,EAAGuC,IAASI,GAClC,IAAK,IAAIxC,EAAI,EAAGA,EAAIgC,EAAKhC,GAAK,EAAGH,EAAGqC,EAAOlC,IAAMgC,CAClD,CACAC,EAAMG,CACP,CACD,CACD,CAEA,SAASD,EAAaQ,EAAOC,EAAeC,EAAY,GACvD,GAAIF,QACH,OAAQ,EAET,GAAqB,IAAjBA,EAAM7D,OACT,OAAQ,EAET,IAAK,IAAIkB,EAAI6C,EAAW7C,EAAI2C,EAAM7D,OAAS8D,EAAc9D,OAAS,EAAGkB,GAAK,EAAG,CAC5E,IAAI8C,GAAQ,EAEZ,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAc9D,OAAQiE,GAAK,EAC9C,GAAIJ,EAAM3C,EAAI+C,KAAOH,EAAcG,GAAI,CACtCD,GAAQ,EACR,KACD,CAED,GAAIA,EACH,OAAO9C,CAET,CACA,OAAQ,CACT,CAMA,SAASgD,EAAe1D,EAAKE,EAAIK,EAAItB,GACpC,MAAM0E,EAAKC,SAASC,yBACpB,IAAIC,EAAO,GACPnB,EAAO,EAEPoB,EAAM,EACV,IAAK,MAAM5D,KAAKH,EAAK,CACpB,GAAIO,EAAGwD,IAAQ,EAAG,CAEjBC,EAAaL,EAAIG,EADFG,EAAqB/D,EAAIyC,EAAKoB,GACd9E,EAAKiF,cACpCJ,EAAO,GACPnB,EAAOoB,CACR,CACAD,GAAQ3D,EACR4D,GAAQ,CACT,CACA,GAAID,EAAKtE,OAAQ,CAEhBwE,EAAaL,EAAIG,EADFG,EAAqB/D,EAAIyC,EAAKzC,EAAGV,QACjBP,EAAKiF,aACrC,CACA,OAAOP,CACR,CAEA,SAASK,EAAaL,EAAI3D,EAAKmE,EAAQC,GACtC,GAAID,EACHR,EAAGU,YAAYT,SAASU,eAAetE,QACjC,CACN,MAAMZ,EAAIwE,SAASW,cAAc,QACjCnF,EAAEiF,YAAYT,SAASU,eAAetE,IAClCoE,EAAM5E,QAlWZ,SAAkBgF,EAAKC,EAAKC,GAAU,EAAMC,EAAM,IACjD,MAAMC,EAAMH,EAAII,OAAO,GACvB,GAAIJ,EAAIK,WAAW,KACdJ,EACHF,EAAIO,QAAQH,GAAOD,SAEZH,EAAIO,QAAQH,OAEd,CACN,MAAMzE,EAAI,CAACyE,EAAKD,GAAKK,KAAK,KACtBN,EACHF,EAAIS,UAAUC,IAAI/E,GAElBqE,EAAIS,UAAUE,OAAOhF,EAEvB,CACD,CAkVoBiF,CAAShG,EAAGgF,GAC9BT,EAAGU,YAAYjF,EAChB,CACD,CAEA,SAAS6E,EAAqB/D,EAAIyC,EAAK0C,GACtC,IAAK,IAAI3E,EAAIiC,EAAKjC,EAAI2E,EAAK3E,GAAK,EAAG,CAClC,MAAMY,EAAIpB,EAAGQ,GACb,IAAKU,EAASgC,SAAS9B,GACtB,OAAO,CAET,CACA,OAAO,CACR,CAEAvC,EAAGuG,eAAyBC,WAC5BxG,EAAGyG,uBA5SH,SAAuBxF,EAAKf,EAAO,CAAC,GAMnCD,EALAC,EAAOwG,OAAOC,OAAO,CACpBxB,aAAe,GACfyB,cAAe,oBACf1F,YAAe,IACbhB,IAGH,MAAOiB,EAAIK,GAAMR,EAAWC,EAAKf,EAAKgB,aACtC,OAAOyD,EAAe1D,EAAKE,EAAIK,EAAItB,EACpC,CA4TA,EA9ZD,CA8ZGH,OAAc,MAAM","file":"ja-segmenter.min.js","sourcesContent":["/**\n * Japanese Text - Segmenter\n *\n * @author Takuto Yanagida\n * @version 2021-12-26\n */\n\n'use strict';\n\nwindow['NACSS']       = window['NACSS']       || {};\nwindow['NACSS']['ja'] = window['NACSS']['ja'] || {};\n\n\n((NS) => {\n\n\t/**\n\t * Style Class Utilities\n\t *\n\t * @author Takuto Yanagida\n\t * @version 2021-11-11\n\t */\n\t\n\tfunction hasClass(tar, cls) {\n\t\tconst key = cls.substr(1);\n\t\tif (cls.startsWith(':')) {\n\t\t\treturn tar.dataset[key] !== undefined;\n\t\t} else {\n\t\t\treturn tar.classList.contains(key);\n\t\t}\n\t}\n\t\n\tfunction setClass(tar, cls, enabled = true, val = '') {\n\t\tconst key = cls.substr(1);\n\t\tif (cls.startsWith(':')) {\n\t\t\tif (enabled) {\n\t\t\t\ttar.dataset[key] = val;\n\t\t\t} else {\n\t\t\t\tdelete tar.dataset[key];\n\t\t\t}\n\t\t} else {\n\t\t\tconst c = [key, val].join('-');\n\t\t\tif (enabled) {\n\t\t\t\ttar.classList.add(c);\n\t\t\t} else {\n\t\t\t\ttar.classList.remove(c);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction getSelector(cls) {\n\t\tif (cls.startsWith(':')) {\n\t\t\treturn `*[data-${cls.substr(1).replace(/([A-Z])/g, c => '-' + c.charAt(0).toLowerCase())}]`;\n\t\t} else {\n\t\t\treturn `*${cls}`;\n\t\t}\n\t}\n\t\n\n\t/**\n\t * Segmenter\n\t *\n\t * @author Takuto Yanagida\n\t * @version 2022-05-27\n\t */\n\t\n\tfunction apply(ts, opts = {}) {\n\t\tif (ts.length === 0) return;\n\t\n\t\topts = Object.assign({\n\t\t\tstyleSegment        : '',\n\t\t\tstyleDisabled       : ':ncNoSegmentation',\n\t\t\tdoDisableOnSelecting: true,\n\t\t\tproperNouns         : [],\n\t\t}, opts);\n\t\tsortProperNouns(opts);\n\t\n\t\tfor (const t of ts) {\n\t\t\tsegmentElement(t, opts);\n\t\t\tif (opts['doDisableOnSelecting']) {\n\t\t\t\tconst f = () => {\n\t\t\t\t\tremoveSegment(t, opts);\n\t\t\t\t\tt.removeEventListener('selectstart', f);\n\t\t\t\t};\n\t\t\t\tt.addEventListener('selectstart', f);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction removeSegment(elm, opts) {\n\t\tconst sty = opts.styleSegment;\n\t\tfor (const s of [...elm.getElementsByTagName('span')]) {\n\t\t\tif ((sty.length === 0 && s.className === '') || hasClass(s, sty)) {\n\t\t\t\tconst df = document.createDocumentFragment();\n\t\t\t\tfor (const c of [...s.childNodes]) {\n\t\t\t\t\tdf.appendChild(c);\n\t\t\t\t}\n\t\t\t\ts.parentNode.replaceChild(df, s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToString(str, opts = {}) {\n\t\topts = Object.assign({\n\t\t\tstyleSegment : '',\n\t\t\tstyleDisabled: ':ncNoSegmentation',\n\t\t\tproperNouns  : [],\n\t\t}, opts);\n\t\tsortProperNouns(opts);\n\t\n\t\tconst [ts, ws] = getSegment(str, opts.properNouns);\n\t\treturn createFragment(str, ts, ws, opts);\n\t}\n\t\n\tfunction sortProperNouns(opts) {\n\t\tconst pns = opts['properNouns'].map(e => [...e]);\n\t\tpns.sort((a, b) => {\n\t\t\treturn b.length - a.length;\n\t\t});\n\t\topts['properNouns'] = pns;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction segmentElement(elm, opts) {\n\t\tfor (const c of [...elm.childNodes]) {\n\t\t\tif (c.nodeType === 1) {  // ELEMENT_NODE\n\t\t\t\tif (!hasClass(c, opts.styleDisabled)) segmentElement(c, opts);\n\t\t\t} else if (c.nodeType === 3) {  // TEXT_NODE\n\t\t\t\tsegmentTextNode(c, opts);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction segmentTextNode(tn, opts) {\n\t\tlet str = tn.textContent;\n\t\tstr = removeWhiteSpacesBetweenZenChars(str);\n\t\n\t\tconst [ts, ws] = getSegment(str, opts.properNouns);\n\t\tconst f = createFragment(str, ts, ws, opts);\n\t\ttn.parentNode.replaceChild(f, tn);\n\t}\n\t\n\t\n\t// -----------------------------------------------------------------------------\n\t\n\t\n\tconst IW = 'そうはいうものの,そればかりでなく,ありとあらゆる,いずれにしても,かけがえのない,そうしてみると,そうすることで,そうでないなら,そうではあるが,それにくわえて,それはさておき,どっちにしても,とはいうものの,なぜかというと,にもかかわらず,いいかえると,いずれにしろ,いずれにせよ,いってみれば,おもいきった,しかしながら,じつのところ,じつはいうと,そうしないと,そうではなく,そのためには,それどころか,それにしても,それによって,そればかりか,それはそうと,どちらにせよ,どっちにせよ,いろいろな,このように,さまざまな,さもないと,したがって,そういえば,そうしたら,そうすると,そうすれば,そうなると,そうなれば,そのかわり,それなのに,それゆえに,たくまざる,だとしたら,だとすると,だとすれば,ではあるが,というのは,というのも,というより,なぜならば,やすやすと,ようするに,ああいう,ああした,あたかも,あらゆる,あるいは,いかなる,いつかは,いっぱい,いろんな,いわゆる,おおきな,おかしな,おそらく,おなじく,おまけに,かえって,かくして,かわりに,くわえて,ぐんぐん,けれども,こういう,こうして,このため,しかるに,しばらく,すなわち,そういう,そうした,そのうえ,そのくせ,そのため,そもそも,それから,それから,それでは,それでも,それとも,それなら,それには,たいした,たいそう,たくさん,だけども,たとえば,たやすく,ちいさな,ちなみに,というか,どういう,とうてい,ときどき,ところが,どころか,ところで,となると,となれば,とにかく,とはいえ,ともあれ,とりわけ,ないしは,なかでも,なぜなら,なぜなら,なだたる,なにしろ,ならびに,はじめに,はずべき,はなはだ,ひいては,ひょんな,ふとした,ほかには,ほかにも,めっきり,もしくは,もっとも,あまり,あらぬ,ありし,あんな,いただ,いつか,いつも,いわば,および,かかる,かなり,きたる,きっと,けれど,ことに,こんな,さらに,しかし,しかも,じつは,じゃあ,すぐに,すぐに,すると,そこで,そして,そっと,それで,それに,そんな,だから,だけど,ただし,だって,たまに,つぎに,つまり,ですが,とある,どうか,ときに,とくに,とても,とんだ,どんな,なにせ,なのに,ならば,ほんの,まさか,または,むこう,むしろ,もっと,もっと,もっと,ものの,やはり,ゆえに,ようは,よって,ああ,あの,ある,かつ,かの,けど,こう,この,さて,さる,そう,その,だが,ただ,では,でも,どう,どの,なお,なぜ,のに,また,もし,よく,わが'.split(',');\n\tconst AW = 'けれども,ところで,において,について,かしら,がてら,くらい,ぐらい,けれど,ってば,ながら,などの,なんぞ,ばかり,ものか,ものの,かい,から,かり,きり,こそ,さえ,しか,ずつ,だけ,だの,たり,つつ,では,ても,でも,とも,なぞ,など,なり,にて,には,ので,のに,のみ,ほど,まで,まま,もん,やら,より,か,が,さ,し,ぜ,ぞ,て,で,と,な,に,ね,の,は,ば,へ,も,や,よ,わ,を'.split(',');\n\t\n\tconst AI1       = 'がおこな,のような,があり,がおき,ができ,がでて'.split(',');\n\tconst PRE_KANJI = 'お,ご'.split(',');\n\tconst PRE_NUM   = '第,約'.split(',');\n\t\n\tfunction getSegment(str, properNouns) {\n\t\tconst ts = createCharTypeArray(str);\n\t\tconst ws = Array(ts.length).fill(0);\n\t\n\t\tweightByCharTypes(ts, ws);\n\t\n\t\tconst strA = [...str];\n\t\tif (properNouns.length) weightByPhrases(strA, ws, properNouns, -1);  // Divide\n\t\tweightByPhrases(strA, ws, IW, -1);  // Divide\n\t\tweightByPhrases(strA, ws, AW, 1);  // Concat\n\t\n\t\tweightByPhrases(strA, ws, AI1, -1, 1);  // Divide with offset\n\t\tweightByPhraseAndType(strA, ts, ws, PRE_KANJI, CLS_ALL,      'H', -1, 2);\n\t\tweightByPhraseAndType(strA, ts, ws, PRE_NUM,   CLS_WO_KANJI, 'N',  0, 2);\n\t\n\t\treturn [ts, ws];\n\t}\n\t\n\t\n\t// -----------------------------------------------------------------------------\n\t\n\t\n\tconst CLS_WO_KANJI = 'SETIKNVO';\n\tconst CLS_ALL      = 'SETIKHNVO';\n\tconst CLS_ORIG     = 'NVO';\n\t\n\tconst CHAR_PATTERNS = [\n\t\t['S', /[「『（［｛〈《【〔〖〘〚＜“]/u],\n\t\t['E', /[」』）］｝〉》】〕〗〙〛＞”]/u],\n\t\t['T', /[、，。．？！を：・]/u],\n\t\t['I', /[ぁ-んゝ]/u],\n\t\t['K', /[ァ-ヴーｱ-ﾝﾞｰ]/u],\n\t\t['H', /[々〆ヵヶ]|[\\u4E00-\\u9FFF]|[\\u{20000}-\\u{2A6DF}]/u],  // Special Characters, CJK Unified Ideographs, CJK Unified Ideographs Extension B\n\t\t['N', /[0-9０-９]/u],\n\t\t['V', /\\s/u],\n\t];\n\t\n\tfunction createCharTypeArray(str) {\n\t\tconst ts = [];\n\t\tfor (const c of str) {\n\t\t\tts.push(getCharType(c));\n\t\t}\n\t\treturn ts;\n\t}\n\t\n\tfunction getCharType(c) {\n\t\tfor (const [t, p] of CHAR_PATTERNS) {\n\t\t\tif (p.test(c)) return t;\n\t\t}\n\t\treturn 'O';\n\t}\n\t\n\t\n\t// -----------------------------------------------------------------------------\n\t\n\t\n\tconst PAIRS = {\n\t\t'*S': -1, 'S*': 2,\n\t\t'*E': 2,\n\t\t'*T': 99, 'T*': -99,\n\t\t'*V': -1, 'V*': -1,\n\t\t'II': 1, 'KK': 1, 'HH': 1,  'NN': 1, 'OO': 1, 'TT': 1,\n\t\t'HI': 1,\n\t\t'NH': 2, 'NK': 1, 'NI': 1,\n\t\t'ON': 1, 'NO': 1,\n\t};\n\t\n\tfunction weightByCharTypes(ts, ws) {\n\t\tfor (let i = 1; i < ts.length; i += 1) {\n\t\t\tconst t0 = ts[i - 1];\n\t\t\tconst t1 = ts[i];\n\t\t\tws[i] += (PAIRS[t0 + t1] ?? 0) + (PAIRS['*' + t1] ?? 0) + (PAIRS[t0 + '*'] ?? 0);\n\t\t}\n\t}\n\t\n\t\n\t// -----------------------------------------------------------------------------\n\t\n\t\n\tfunction divideByPhrases(strA, ws, phrases) {\n\t\tfor (const ph of phrases) {\n\t\t\tconst phA = [...ph];\n\t\t\tconst phL = phA.length;\n\t\n\t\t\tfor (let bgn = 0;;) {\n\t\t\t\tconst idx0 = indexOfArray(strA, phA, bgn);\n\t\t\t\tif (idx0 === -1) break;\n\t\t\t\tconst idx1 = idx0 + phL;\n\t\n\t\t\t\tws[idx0] -= phL;\n\t\t\t\tfor (let i = 1; i < phL; i += 1) ws[idx0 + i] += phL;\n\t\t\t\tbgn = idx1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction divideByCombinedPhrases(strA, ws, phrases, al) {\n\t\tfor (const ph of phrases) {\n\t\t\tconst phA = [...ph];\n\t\t\tconst phL = phA.length;\n\t\n\t\t\tfor (let bgn = 0;;) {\n\t\t\t\tconst idx0 = indexOfArray(strA, phA, bgn);\n\t\t\t\tif (idx0 === -1) break;\n\t\t\t\tconst idx1 = idx0 + phL;\n\t\n\t\t\t\tws[idx0 + al] -= phL - al;\n\t\t\t\tfor (let i = 1; i < phL - al; i += 1) ws[idx0 + al + i] += phL - al;\n\t\t\t\tbgn = idx1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction concatByPhrases(strA, ws, phrases) {\n\t\tfor (const ph of phrases) {\n\t\t\tconst phA = [...ph];\n\t\t\tconst phL = phA.length;\n\t\n\t\t\tfor (let bgn = 0; ;) {\n\t\t\t\tconst idx0 = indexOfArray(strA, phA, bgn);\n\t\t\t\tif (idx0 === -1) break;\n\t\t\t\tconst idx1 = idx0 + phL;\n\t\n\t\t\t\tws[idx0] += phL;\n\t\t\t\tfor (let i = 1; i < phL; i += 1) ws[idx0 + i] += phL;\n\t\t\t\tbgn = idx1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction weightByPhrases(strA, ws, phrases, factor, offset = 0) {\n\t\tfor (const ph of phrases) {\n\t\t\tconst phA = [...ph];\n\t\t\tconst phL = phA.length;\n\t\n\t\t\tfor (let bgn = 0;;) {\n\t\t\t\tconst idx0 = indexOfArray(strA, phA, bgn);\n\t\t\t\tif (idx0 === -1) break;\n\t\t\t\tconst idx1 = idx0 + phL;\n\t\n\t\t\t\tws[idx0 + offset] += (phL - offset) * factor;\n\t\t\t\tfor (let i = 1; i < phL - offset; i += 1) {\n\t\t\t\t\tws[idx0 + offset + i] += (phL - offset);\n\t\t\t\t}\n\t\t\t\tbgn = idx1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction weightByPhraseAndType(strA, ts, ws, phrases, prevCts, nextCts, prevW, nextW) {\n\t\tconst tsL = ts.length;\n\t\n\t\tfor (const ph of phrases) {\n\t\t\tconst phA = [...ph];\n\t\t\tconst phL = phA.length;\n\t\n\t\t\tfor (let bgn = 0; ;) {\n\t\t\t\tconst idx0 = indexOfArray(strA, phA, bgn);\n\t\t\t\tif (idx0 === -1) break;\n\t\t\t\tconst idx1 = idx0 + phL;\n\t\n\t\t\t\tif (\n\t\t\t\t\t(idx0 === 0   || (idx0 !== 0 && prevCts.includes(ts[idx0 - 1]))) &&\n\t\t\t\t\t(idx1 === tsL || (idx1 < tsL && nextCts.includes(ts[idx1])))\n\t\t\t\t) {\n\t\t\t\t\tws[idx0] += prevW;\n\t\t\t\t\tif (idx1 < ws.length) ws[idx1] += nextW;\n\t\t\t\t\tfor (let i = 1; i < phL; i += 1) ws[idx0 + i] += phL;\n\t\t\t\t}\n\t\t\t\tbgn = idx1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction indexOfArray(array, searchElement, fromIndex = 0) {\n\t\tif (array === null || array === undefined) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (array.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (let i = fromIndex; i < array.length - searchElement.length + 1; i += 1) {\n\t\t\tlet match = true;\n\t\n\t\t\tfor (let j = 0; j < searchElement.length; j += 1) {\n\t\t\t\tif (array[i + j] !== searchElement[j]) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\t\n\t// -----------------------------------------------------------------------------\n\t\n\t\n\tfunction createFragment(str, ts, ws, opts) {\n\t\tconst df = document.createDocumentFragment();\n\t\tlet temp = '';\n\t\tlet bgn  = 0;\n\t\n\t\tlet idx = 0;\n\t\tfor (const c of str) {\n\t\t\tif (ws[idx] <= 0) {\n\t\t\t\tconst isOrig = isOriginalCharPhrase(ts, bgn, idx);\n\t\t\t\tappendPhrase(df, temp, isOrig, opts.styleSegment);\n\t\t\t\ttemp = '';\n\t\t\t\tbgn  = idx;\n\t\t\t}\n\t\t\ttemp += c;\n\t\t\tidx  += 1;\n\t\t}\n\t\tif (temp.length) {\n\t\t\tconst isOrig = isOriginalCharPhrase(ts, bgn, ts.length);\n\t\t\tappendPhrase(df, temp, isOrig, opts.styleSegment);\n\t\t}\n\t\treturn df;\n\t}\n\t\n\tfunction appendPhrase(df, str, isOrig, style) {\n\t\tif (isOrig) {\n\t\t\tdf.appendChild(document.createTextNode(str));\n\t\t} else {\n\t\t\tconst e = document.createElement('span');\n\t\t\te.appendChild(document.createTextNode(str));\n\t\t\tif (style.length) setClass(e, style);\n\t\t\tdf.appendChild(e);\n\t\t}\n\t}\n\t\n\tfunction isOriginalCharPhrase(ts, bgn, end) {\n\t\tfor (let i = bgn; i < end; i += 1) {\n\t\t\tconst t = ts[i];\n\t\t\tif (!CLS_ORIG.includes(t)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tNS.applySegmenter         = initialize;\n\tNS.applySegmenterToString = applyToString;\n\n\t/**\n\t * Common Functions\n\t *\n\t * @author Takuto Yanagida\n\t * @version 2021-11-03\n\t */\n\t\n\tfunction removeHeadWhiteSpaces(str) {\n\t\tconst mzs = str.match(/^[\\n\\r\\t ]*(\\u3000*)/);\n\t\tconst zs = (mzs && 1 < mzs.length) ? mzs[1] : '';\n\t\treturn zs + str.replace(/^\\s+/g, '');  // Trim left\n\t}\n\t\n\tfunction removeTailWhiteSpaces(str) {\n\t\treturn str.replace(/\\s+$/g, '');  // Trim right\n\t}\n\t\n\tfunction removeWhiteSpacesBetweenZenChars(str) {\n\t\t// White space character class excluding \\u3000\n\t\t// [ \\f\\n\\r\\t\\v​\\u00a0​\\u180e\\u2000​-\\u200a​\\u2028\\u2029\\u202f\\u205f​\\ufeff]\n\t\treturn str.replace(/([^\\x01-\\x7E\\xA1-\\xDF]+)([\\t\\n]+|[ \\f\\n\\r\\t\\v\\u00a0\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\ufeff]{2})([^\\x01-\\x7E\\xA1-\\xDF]+)/g, (match, g1, d, g2) => g1 + g2);\n\t}\n\t\n\n})(window['NACSS']['ja']);\n"]}